/* array.c */
void memclear(VALUE *mem, int size);
VALUE ary_new2(int len);
VALUE ary_new(void);
VALUE ary_new3(int n, ...);
VALUE ary_new4(int n, VALUE *elts);
VALUE assoc_new(VALUE car, VALUE cdr);
VALUE ary_push(struct RArray *ary, VALUE item);
VALUE ary_pop(struct RArray *ary);
VALUE ary_shift(struct RArray *ary);
VALUE ary_unshift(struct RArray *ary, int item);
VALUE ary_entry(struct RArray *ary, int offset);
VALUE ary_join(struct RArray *ary, struct RString *sep);
VALUE ary_to_s(VALUE ary);
VALUE ary_print_on(struct RArray *ary, VALUE port);
VALUE rb_to_a(VALUE obj);
VALUE ary_reverse(struct RArray *ary);
VALUE ary_sort_bang(struct RArray *ary);
VALUE ary_sort(VALUE ary);
VALUE ary_delete_at(struct RArray *ary, VALUE at);
VALUE ary_plus(struct RArray *x, struct RArray *y);
VALUE ary_concat(struct RArray *x, struct RArray *y);
VALUE ary_assoc(struct RArray *ary, VALUE key);
VALUE ary_rassoc(struct RArray *ary, VALUE value);
void Init_Array(void);
/* bignum.c */
VALUE big_clone(struct RBignum *x);
void big_2comp(struct RBignum *x);
VALUE bignorm(struct RBignum *x);
VALUE uint2big(UINT n);
VALUE int2big(int n);
VALUE uint2inum(UINT n);
VALUE int2inum(int n);
VALUE str2inum(char *str, int base);
VALUE big2str(struct RBignum *x, int base);
int big2int(struct RBignum *x);
VALUE big_to_i(VALUE x);
VALUE dbl2big(double d);
double big2dbl(struct RBignum *x);
VALUE big_to_f(VALUE x);
VALUE big_plus(VALUE x, VALUE y);
VALUE big_minus(VALUE x, VALUE y);
VALUE big_mul(struct RBignum *x, struct RBignum *y);
VALUE big_pow(VALUE x, VALUE y);
VALUE big_and(struct RBignum *x, struct RBignum *y);
VALUE big_or(struct RBignum *x, struct RBignum *y);
VALUE big_xor(struct RBignum *x, struct RBignum *y);
VALUE big_lshift(struct RBignum *x, VALUE y);
VALUE big_rand(struct RBignum *max);
void Init_Bignum(void);
/* class.c */
VALUE class_new(struct RClass *super);
VALUE singleton_class_new(struct RClass *super);
VALUE singleton_class_clone(struct RClass *class);
VALUE rb_define_class_id(ID id, struct RBasic *super);
VALUE rb_define_class(char *name, VALUE super);
VALUE rb_define_class_under(VALUE under, char *name, VALUE super);
VALUE module_new(void);
VALUE rb_define_module_id(ID id);
VALUE rb_define_module(char *name);
VALUE rb_define_module_under(VALUE under, char *name);
void rb_include_module(struct RClass *class, struct RClass *module);
void rb_define_method_id(struct RClass *class, ID name, VALUE (*func)(void), int argc);
void rb_define_method(struct RClass *class, char *name, VALUE (*func)(void), int argc);
void rb_undef_method(struct RClass *class, char *name);
void rb_define_private_method(struct RClass *class, char *name, VALUE (*func)(void), int argc);
VALUE rb_singleton_class(struct RBasic *obj);
void rb_define_singleton_method(VALUE obj, char *name, VALUE (*func)(void), int argc);
void rb_define_module_function(VALUE module, char *name, VALUE (*func)(void), int argc);
void rb_define_alias(struct RClass *class, char *name1, char *name2);
void rb_define_attr(struct RClass *class, ID id, int pub);
int rb_scan_args(int argc, VALUE *argv, char *fmt, ...);
/* compar.c */
void Init_Comparable(void);
/* dir.c */
void Init_Dir(void);
/* dln.c */
void dln_load(char *file);
char *dln_find_exe(char *fname, char *path);
char *dln_find_file(char *fname, char *path);
/* dmyext.c */
void Init_ext(void);
/* enum.c */
void rb_each(VALUE obj);
VALUE enum_length(VALUE obj);
void Init_Enumerable(void);
/* error.c */
void Error(char *fmt, ...);
void Error_Append(char *fmt, ...);
void Warning(char *fmt, ...);
void Bug(char *fmt, ...);
void Check_Type(VALUE x, int t);
VALUE exc_new0(VALUE etype, char *ptr, UINT len);
VALUE exc_new(VALUE etype, char *s);
VALUE exc_new2(VALUE etype, struct RString *str);
void Init_Exception(void);
void Raise(VALUE exc, char *fmt, ...);
void TypeError(char *fmt, ...);
void ArgError(char *fmt, ...);
void NameError(char *fmt, ...);
void IndexError(char *fmt, ...);
void Fail(char *fmt, ...);
void rb_notimplement(void);
void LoadError(char *fmt, ...);
void Fatal(char *fmt, ...);
void rb_sys_fail(char *mesg);
/* eval.c */
void rb_add_method(struct RClass *class, ID mid, NODE *node, int noex);
void rb_alias(struct RClass *class, ID name, ID def);
void rb_export_method(struct RClass *class, ID name, int noex);
int rb_method_boundp(struct RClass *class, ID id);
void rb_clear_cache(void);
VALUE dyna_var_defined(ID id);
VALUE dyna_var_ref(ID id);
VALUE dyna_var_asgn(ID id, VALUE value);
void ruby_init(int argc, char **argv, char **envp);
void ruby_run(void);
VALUE rb_eval_string(char *str);
void rb_eval_cmd(VALUE cmd, VALUE arg);
void rb_trap_eval(VALUE cmd, int sig);
int rb_test_false_or_nil(VALUE v);
int rb_respond_to(VALUE obj, ID id);
void rb_exit(int status);
void rb_break(void);
void rb_raise(VALUE mesg);
void rb_fatal(VALUE mesg);
void rb_interrupt(void);
int iterator_p(void);
VALUE rb_yield_0(VALUE val, VALUE self);
VALUE rb_yield(VALUE val);
VALUE rb_iterate(VALUE (*it_proc)(void), void *data1, VALUE (*bl_proc)(void), void *data2);
VALUE rb_rescue(VALUE (*b_proc)(void), void *data1, VALUE (*r_proc)(void), void *data2);
VALUE rb_ensure(VALUE (*b_proc)(void), void *data1, VALUE (*e_proc)(void), void *data2);
VALUE rb_apply(VALUE recv, ID mid, struct RArray *args);
VALUE rb_funcall(VALUE recv, ID mid, int n, ...);
VALUE rb_funcall2(VALUE recv, ID mid, int argc, VALUE *argv);
void rb_backtrace(void);
ID rb_frame_last_func(void);
VALUE f_load(VALUE obj, struct RString *fname);
void rb_provide(char *feature);
VALUE f_require(VALUE obj, struct RString *fname);
VALUE class_s_new(int argc, VALUE *argv, VALUE class);
void rb_extend_object(VALUE obj, VALUE module);
void Init_eval(void);
void Init_load(void);
VALUE f_lambda(void);
void Init_Proc(void);
int thread_curr(void);
void gc_mark_threads(void);
void thread_schedule(void);
void thread_wait_fd(int fd);
void thread_fd_writable(int fd);
void thread_wait_for(struct timeval time);
int thread_select(int max, fd_set *read, fd_set *write, fd_set *except, struct timeval *timeout);
int th_cur(void);
void thread_sleep(void);
VALUE thread_create(VALUE (*fn)(void), void *arg);
void thread_interrupt(void);
void Init_Thread(void);
/* file.c */
VALUE file_open(char *fname, char *mode);
int eaccess(char *path, int mode);
VALUE test_S(VALUE obj, struct RString *fname);
VALUE file_chown(VALUE obj, VALUE owner, VALUE group);
void Init_File(void);
/* fnmatch.c */
int fnmatch(char *pattern, char *string, int flags);
/* gc.c */
void *xmalloc(unsigned long size);
void *xcalloc(unsigned long n, unsigned long size);
void *xrealloc(void *ptr, unsigned long size);
VALUE gc_s_enable(void);
VALUE gc_s_disable(void);
void rb_global_variable(VALUE *var);
struct RBasic *newobj(void);
VALUE data_object_alloc(VALUE class, void *datap, void (*dmark)(void), void (*dfree)(void));
void gc_mark_locations(VALUE *start, VALUE *end);
void gc_mark_maybe(void *obj);
void gc_mark(register RVALUE *obj);
void gc_mark_frame(struct FRAME *frame);
void gc(void);
void init_stack(void);
void init_heap(void);
void Init_GC(void);
/* glob.c */
int glob_pattern_p(char *pattern);
char **glob_vector(char *pat, char *dir);
char **glob_filename(char *pathname);
/* hash.c */
VALUE hash_new2(VALUE class);
VALUE hash_new(void);
VALUE hash_aref(struct RHash *hash, VALUE key);
VALUE hash_aset(struct RHash *hash, VALUE key, VALUE val);
VALUE hash_empty_p(struct RHash *hash);
VALUE f_getenv(VALUE obj, struct RString *name);
VALUE f_setenv(VALUE obj, struct RString *name, struct RString *value);
void Init_Hash(void);
/* inits.c */
/* io.c */
void eof_error(void);
void io_writable(OpenFile *fptr);
void io_readable(OpenFile *fptr);
void io_wrong_type(void);
VALUE io_write(VALUE io, struct RString *str);
VALUE io_gets_method(int argc, VALUE argv, VALUE io);
VALUE io_gets(VALUE io);
VALUE io_getc(VALUE io);
VALUE io_ungetc(VALUE io, VALUE c);
void io_fptr_finalize(OpenFile *fptr);
VALUE io_close(VALUE io);
int io_mode_flags(char *mode);
FILE *rb_fopen(char *fname, char *mode);
FILE *rb_fdopen(int fd, char *mode);
VALUE f_p(int obj, int val);
VALUE f_gets(int argc, VALUE argv);
VALUE rb_str_setter(VALUE val, ID id, VALUE *var);
void io_ctl(VALUE io, VALUE req, struct RString *arg, int io_p);
void Init_IO(void);
/* main.c */
void main(int argc, char **argv, char **envp);
/* math.c */
void Init_Math(void);
/* numeric.c */
void num_zerodiv(void);
VALUE num_coerce_bin(VALUE x, VALUE y);
VALUE float_new(double d);
VALUE flo_pow(struct RFloat *x, struct RFloat *y);
int num2int(VALUE val);
VALUE num2fix(VALUE val);
VALUE fix2str(VALUE x, int base);
VALUE fix_to_s(VALUE in);
VALUE num_upto(VALUE from, VALUE to);
VALUE fix_upto(VALUE from, VALUE to);
void Init_Numeric(void);
/* object.c */
int rb_equal(VALUE obj1, VALUE obj2);
int rb_eql(VALUE obj1, VALUE obj2);
VALUE krn_to_s(VALUE obj);
VALUE rb_inspect(VALUE obj);
VALUE obj_is_instance_of(VALUE obj, VALUE c);
VALUE obj_is_kind_of(VALUE obj, VALUE c);
VALUE obj_alloc(VALUE class);
ID rb_to_id(VALUE name);
VALUE f_float(VALUE obj, VALUE arg);
VALUE rb_class_of(VALUE obj);
int rb_type(VALUE obj);
int rb_special_const_p(VALUE obj);
void Init_Object(void);
/* pack.c */
void Init_pack(void);
/* process.c */
int rb_proc_exec(char *str);
void rb_syswait(int pid);
VALUE f_sleep(int argc, VALUE *argv);
void Init_process(void);
/* random.c */
void Init_Random(void);
/* range.c */
VALUE range_new(VALUE first, VALUE last);
VALUE range_beg_end(VALUE range, int *begp, int *endp);
void Init_Range(void);
/* re.c */
int str_cicmp(struct RString *str1, struct RString *str2);
int reg_search(struct RRegexp *reg, struct RString *str, int start, struct re_registers *regs);
VALUE reg_nth_defined(int nth, struct RMatch *match);
VALUE reg_nth_match(int nth, struct RMatch *match);
VALUE reg_last_match(struct RMatch *match);
VALUE reg_match_pre(struct RMatch *match);
VALUE reg_match_post(struct RMatch *match);
VALUE reg_match_last(struct RMatch *match);
void reg_free(Regexp *rp);
VALUE reg_new(char *s, int len, int ci);
VALUE reg_regcomp(struct RString *str);
VALUE reg_match(struct RRegexp *re, struct RString *str);
VALUE reg_match2(struct RRegexp *re);
VALUE reg_regsub(struct RString *str, struct RString *src, struct re_registers *regs);
void rb_set_kcode(char *code);
void Init_Regexp(void);
/* regex.c */
long re_set_syntax(long syntax);
char *re_compile_pattern(char *pattern, size_t size, struct re_pattern_buffer *bufp);
void re_compile_fastmap(struct re_pattern_buffer *bufp);
int re_search(struct re_pattern_buffer *bufp, char *string, int size, int startpos, int range, struct re_registers *regs);
int re_match(struct re_pattern_buffer *bufp, char *string_arg, int size, int pos, struct re_registers *regs);
void re_copy_registers(struct re_registers *regs1, struct re_registers *regs2);
void re_free_registers(struct re_registers *regs);
/* ruby.c */
void rb_load_file(char *fname);
void ruby_script(char *name);
void ruby_options(int argc, char **argv, char **envp);
/* signal.c */
VALUE f_kill(int argc, VALUE *argv);
void gc_mark_trap_list(void);
void posix_signal(int signum, void (*handler)(void));
void rb_trap_exit(void);
void rb_trap_exec(void);
void Init_signal(void);
/* sprintf.c */
VALUE f_sprintf(int argc, VALUE *argv);
/* st.c */
st_table *st_init_table_with_size(struct st_hash_type *type, int size);
st_table *st_init_table(struct st_hash_type *type);
st_table *st_init_numtable(void);
st_table *st_init_strtable(void);
int st_free_table(st_table *table);
int st_lookup(st_table *table, register char *key, char **value);
int st_insert(register st_table *table, register char *key, char *value);
int st_add_direct(st_table *table, char *key, char *value);
int st_find_or_add(st_table *table, char *key, char ***slot);
st_table *st_copy(st_table *old_table);
int st_delete(register st_table *table, register char **key, char **value);
int st_foreach(st_table *table, enum st_retval (*func)(void), char *arg);
/* string.c */
VALUE str_new(char *ptr, UINT len);
VALUE str_new2(char *ptr);
VALUE str_new3(struct RString *str);
VALUE obj_as_string(VALUE obj);
VALUE str_dup(struct RString *str);
VALUE str_plus(struct RString *str1, struct RString *str2);
VALUE str_times(struct RString *str, VALUE times);
VALUE str_substr(struct RString *str, int start, int len);
VALUE str_subseq(struct RString *str, int beg, int end);
void str_modify(struct RString *str);
VALUE str_freeze(VALUE str);
VALUE str_dup_freezed(VALUE str);
VALUE str_resize(struct RString *str, UINT len);
VALUE str_cat(struct RString *str, char *ptr, UINT len);
int str_hash(struct RString *str);
int str_cmp(struct RString *str1, struct RString *str2);
VALUE str_upto(VALUE beg, VALUE end);
VALUE str_split(struct RString *str, char *sep0);
VALUE str_ljust(struct RString *str, VALUE w);
VALUE str_rjust(struct RString *str, VALUE w);
VALUE str_center(struct RString *str, VALUE w);
void Init_String(void);
/* struct.c */
VALUE struct_define(char *name, ...);
VALUE struct_alloc(VALUE class, struct RArray *values);
VALUE struct_new(VALUE class, ...);
void Init_Struct(void);
/* time.c */
VALUE time_new(int sec, int usec);
struct timeval time_timeval(VALUE time);
void Init_Time(void);
/* util.c */
unsigned long scan_oct(char *start, int len, int *retlen);
unsigned long scan_hex(char *start, int len, int *retlen);
/* variable.c */
st_table *new_idhash(void);
void Init_var_tables(void);
char *rb_class2path(VALUE class);
VALUE rb_class_path(VALUE class);
void rb_set_class_path(VALUE class, VALUE under, char *name);
VALUE rb_path2class(char *path);
void rb_name_class(VALUE class, ID id);
void rb_autoload(char *class, char *filename);
VALUE f_autoload(VALUE obj, VALUE class, struct RString *file);
char *rb_class2name(struct RClass *class);
struct global_entry *rb_global_entry(ID id);
void gc_mark_global_tbl(void);
void rb_define_hooked_variable(char *name, VALUE *var, VALUE (*getter)(void), void (*setter)(void));
void rb_define_variable(char *name, VALUE *var);
void rb_define_readonly_variable(char *name, VALUE *var);
void rb_define_virtual_variable(char *name, VALUE (*getter)(void), void (*setter)(void));
void rb_trace_eval(VALUE cmd, VALUE val);
VALUE f_trace_var(int argc, VALUE *argv);
VALUE f_untrace_var(int argc, VALUE *argv);
VALUE rb_gvar_get(struct global_entry *entry);
VALUE rb_gvar_set(struct global_entry *entry, VALUE val);
VALUE rb_gvar_set2(char *name, VALUE val);
VALUE rb_gvar_defined(struct global_entry *entry);
VALUE rb_ivar_get(struct RObject *obj, ID id);
VALUE rb_ivar_set(struct RObject *obj, ID id, VALUE val);
VALUE rb_ivar_defined(struct RObject *obj, ID id);
VALUE rb_const_get_at(struct RClass *class, ID id);
VALUE rb_const_get(struct RClass *class, ID id);
int rb_const_defined_at(struct RClass *class, ID id);
int rb_const_defined(struct RClass *class, ID id);
int rb_autoload_defined(ID id);
void rb_const_set(struct RClass *class, ID id, VALUE val);
void rb_define_const(struct RClass *class, char *name, VALUE val);
void rb_define_global_const(char *name, VALUE val);
VALUE rb_iv_get(VALUE obj, char *name);
VALUE rb_iv_set(VALUE obj, char *name, VALUE val);
/* version.c */
void Init_version(void);
void show_version(void);
void show_copyright(void);
/* parse.y */
NODE *compile_string(char *f, char *s, int len);
NODE *compile_file(char *f, VALUE file, int start);
int nextc(void);
void pushback(int c);
char *newtok(void);
void tokadd(int c);
NODE *newnode(enum node_type type, NODE *a0, NODE *a1, NODE *a2);
enum node_type nodetype(NODE *node);
ID id_attrset(ID id);
void yyappend_print(void);
void yywhile_loop(int chop, int split);
void Init_sym(void);
ID rb_intern(char *name);
char *rb_id2name(ID id);
void rb_const_check(struct RClass *class, struct RClass *module);
void local_var_append(ID id);
VALUE backref_get(void);
void backref_set(VALUE val);
VALUE lastline_get(void);
void lastline_set(VALUE val);
